<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omegle Clone - PobreCraft</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f1f1f1;
            font-family: sans-serif;
        }
        .video-container {
            position: relative;
            background: #000;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 8px;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        /* Important: Do not use display:none, otherwise WebGL texture updates fail */
        #sourceVideo {
            position: absolute;
            top: 0;
            left: 0;
            width: 10px;
            height: 10px;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }
        
        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #localCanvas {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px; /* Thumbnail size */
            height: 120px;
            border: 2px solid white;
            border-radius: 4px;
            z-index: 10;
            transform: scaleX(-1); /* Mirror effect for self-view */
            background: #222;
        }

        /* Chat styles */
        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 4px;
            word-wrap: break-word;
        }
        .stranger-msg { color: #2563eb; }
        .you-msg { color: #4b5563; }
        .system-msg { color: #555; font-style: italic; font-size: 0.9em; text-align: center; display: block; background: #e5e7eb; border-radius: 10px; padding: 4px; margin: 5px 0; }

        /* Modal */
        #loginModal {
            background-color: rgba(0,0,0,0.85);
        }
        
        /* Loading Overlay */
        #loadingOverlay {
            background-color: rgba(255,255,255,0.9);
            z-index: 40;
        }
    </style>
</head>
<body class="h-screen flex flex-col">

    <!-- Login Modal -->
    <div id="loginModal" class="fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-md">
            <h2 class="text-2xl font-bold mb-4 text-center text-gray-800">Criar Perfil</h2>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Apelido</label>
                    <input type="text" id="usernameInput" class="w-full border border-gray-300 p-2 rounded focus:ring-2 focus:ring-blue-500 outline-none" placeholder="Ex: BatataKiller">
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Bio (Status)</label>
                    <input type="text" id="bioInput" class="w-full border border-gray-300 p-2 rounded focus:ring-2 focus:ring-blue-500 outline-none" placeholder="Ex: Bora conversar!">
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Foto de Perfil</label>
                    <div class="flex items-center gap-4 mt-2 bg-gray-50 p-3 rounded border border-gray-200">
                        <div class="w-16 h-16 rounded-full bg-gray-300 overflow-hidden border-2 border-white shadow">
                            <img id="profilePreview" src="https://via.placeholder.com/150" class="w-full h-full object-cover">
                        </div>
                        <input type="file" id="fileInput" accept="image/*" class="text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                    </div>
                </div>

                <div class="pt-2">
                    <button id="loginBtn" class="w-full bg-blue-600 text-white font-bold py-3 rounded-lg hover:bg-blue-700 transition shadow-lg">
                        ENTRAR NO CHAT
                    </button>
                    <p id="loginError" class="text-red-500 text-xs text-center mt-2 hidden">Preencha o nome!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header class="bg-white p-3 shadow-sm flex justify-between items-center z-30">
        <div class="flex items-center gap-2">
            <h1 class="text-xl md:text-2xl font-bold text-gray-800 tracking-tight"><span class="text-blue-600">Omegle</span> Clone</h1>
        </div>
        
        <!-- User Info Header -->
        <div class="flex items-center gap-3 bg-gray-100 py-1 px-3 rounded-full" id="headerUserInfo">
            <span class="text-xs text-gray-500">Faça login...</span>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col md:flex-row p-2 md:p-4 gap-4 overflow-hidden relative">
        
        <!-- Video Section -->
        <div class="flex-1 flex flex-col gap-3 min-h-0">
            <div class="video-container flex-1 relative shadow-xl bg-gray-900 rounded-xl border border-gray-800">
                <!-- Status Overlay inside video -->
                <div class="absolute inset-0 flex items-center justify-center pointer-events-none z-10" id="videoOverlay">
                    <span id="statusText" class="bg-black/70 text-white px-6 py-3 rounded-full font-bold backdrop-blur-sm shadow-lg">
                        Clique em INICIAR para começar
                    </span>
                </div>

                <video id="remoteVideo" autoplay playsinline></video>
                
                <!-- Source video (hidden visually but active in DOM) -->
                <video id="sourceVideo" autoplay playsinline muted></video>
                
                <!-- Processed Output (Local) -->
                <canvas id="localCanvas"></canvas>
                
                <!-- Labels -->
                <div class="absolute top-4 left-4 z-20 flex items-center gap-2 bg-black/50 text-white px-3 py-1 rounded-full backdrop-blur-md">
                    <div class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></div>
                    <span class="font-bold text-xs uppercase tracking-wider">Estranho</span>
                </div>

                <div class="absolute bottom-4 right-48 z-20 flex items-center gap-2 bg-black/50 text-white px-3 py-1 rounded-full backdrop-blur-md hidden md:flex">
                    <span class="font-bold text-xs uppercase tracking-wider">Você</span>
                </div>
            </div>

            <!-- Controls -->
            <div class="bg-white p-3 md:p-4 rounded-xl shadow-md flex flex-wrap gap-4 items-center justify-between border border-gray-200">
                <div class="flex flex-wrap gap-4 items-center flex-1">
                    <div class="flex flex-col min-w-[140px]">
                        <label class="text-[10px] font-bold text-gray-500 uppercase tracking-wide mb-1">Distorção (WebGL)</label>
                        <select id="distortionSelect" class="border border-gray-300 rounded p-1.5 bg-gray-50 text-sm focus:ring-2 focus:ring-blue-500 outline-none">
                            <option value="none">Normal</option>
                            <option value="bulge">Olho/Boca Gigante (Bulge)</option>
                            <option value="pinch">Cara Apertada (Pinch)</option>
                            <option value="swirl">Redemoinho (Swirl)</option>
                        </select>
                    </div>
                    
                    <div class="text-xs text-gray-500 italic hidden md:block max-w-[200px]">
                        <i class="fas fa-info-circle mr-1"></i>Mova o mouse sobre seu vídeo para controlar o efeito!
                    </div>
                </div>

                <div class="flex gap-2 w-full md:w-auto">
                    <button id="startBtn" class="flex-1 md:flex-none bg-blue-600 hover:bg-blue-700 text-white font-bold py-2.5 px-8 rounded-lg transition shadow-lg transform active:scale-95 flex items-center justify-center gap-2">
                        <i class="fas fa-play"></i> INICIAR
                    </button>
                    <button id="stopBtn" class="flex-1 md:flex-none bg-red-500 hover:bg-red-600 text-white font-bold py-2.5 px-8 rounded-lg transition hidden shadow-lg transform active:scale-95 flex items-center justify-center gap-2">
                        <i class="fas fa-times"></i> PARAR (ESC)
                    </button>
                </div>
            </div>
        </div>

        <!-- Chat Section -->
        <div class="w-full md:w-[350px] bg-white rounded-xl shadow-md flex flex-col h-[40vh] md:h-full relative border border-gray-200 overflow-hidden">
            
            <!-- Stranger Profile Header (Dynamic) -->
            <div id="strangerProfile" class="hidden p-3 border-b bg-blue-50 flex items-center gap-3 transition-all">
                <img id="strangerPic" src="" class="w-10 h-10 rounded-full object-cover border-2 border-white shadow-sm bg-gray-200">
                <div class="overflow-hidden">
                    <div id="strangerName" class="font-bold text-gray-800 truncate">Estranho</div>
                    <div id="strangerBio" class="text-xs text-gray-600 italic truncate">...</div>
                </div>
            </div>

            <!-- Messages Area -->
            <div id="chatArea" class="flex-1 p-4 overflow-y-auto bg-gray-50/50 space-y-2">
                <div class="system-msg mt-4">
                    <i class="fas fa-shield-alt mr-1"></i> Bem-vindo ao Omegle Clone! Configure seu perfil e clique em <b>INICIAR</b> para encontrar alguém aleatório.
                </div>
            </div>
            
            <!-- Input Area -->
            <div class="p-3 bg-white border-t border-gray-200 flex gap-2">
                <input id="chatInput" type="text" placeholder="Digite uma mensagem..." class="flex-1 border border-gray-300 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition" disabled autocomplete="off">
                <button id="sendBtn" class="bg-gray-100 text-gray-400 px-4 py-2 rounded-lg hover:bg-blue-600 hover:text-white transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>

    </main>

    <!-- Script Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, deleteDoc, getDoc, setDoc, query, where, getDocs, limit, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // --- Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyDsDeOjhkkKtXK8kBpuVORQ1FTI_EdBTdU",
            authDomain: "pobrecraft-c517c.firebaseapp.com",
            projectId: "pobrecraft-c517c",
            storageBucket: "pobrecraft-c517c.firebasestorage.app",
            messagingSenderId: "906438912132",
            appId: "1:906438912132:web:a3d9827600d3c0a52dbad1"
        };

        let app, db;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            console.log("Firebase Initialized");
        } catch (e) {
            alert("Erro ao conectar no Firebase: " + e.message);
        }

        const servers = {
            iceServers: [
                { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }
            ]
        };

        // --- DOM Elements ---
        const sourceVideo = document.getElementById('sourceVideo');
        const localCanvas = document.getElementById('localCanvas');
        const remoteVideo = document.getElementById('remoteVideo');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const chatArea = document.getElementById('chatArea');
        const chatInput = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');
        const statusText = document.getElementById('statusText');
        const distortionSelect = document.getElementById('distortionSelect');
        
        // Login
        const loginModal = document.getElementById('loginModal');
        const usernameInput = document.getElementById('usernameInput');
        const bioInput = document.getElementById('bioInput');
        const fileInput = document.getElementById('fileInput');
        const profilePreview = document.getElementById('profilePreview');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const headerUserInfo = document.getElementById('headerUserInfo');
        
        // Stranger
        const strangerProfile = document.getElementById('strangerProfile');
        const strangerName = document.getElementById('strangerName');
        const strangerBio = document.getElementById('strangerBio');
        const strangerPic = document.getElementById('strangerPic');

        // --- Variables ---
        let localStream = null;
        let canvasStream = null;
        let peerConnection = null;
        let dataChannel = null;
        let roomId = null;
        let role = null; // 'caller' | 'callee'
        let unsubscribeRoom = null;
        let unsubscribeCandidates = null;
        
        let currentUser = {
            username: "",
            bio: "",
            pic: "https://via.placeholder.com/150"
        };

        // WebGL Globals
        let gl = null;
        let shaderProgram = null;
        let texture = null;
        let animationFrameId = null;
        let mouseX = 0.5;
        let mouseY = 0.5;

        // --- 1. Login Logic ---
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onloadend = () => {
                const img = new Image();
                img.src = reader.result;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const MAX_SIZE = 200; // Small size for performance
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > height) {
                        if (width > MAX_SIZE) { height *= MAX_SIZE / width; width = MAX_SIZE; }
                    } else {
                        if (height > MAX_SIZE) { width *= MAX_SIZE / height; height = MAX_SIZE; }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    currentUser.pic = canvas.toDataURL('image/jpeg', 0.85);
                    profilePreview.src = currentUser.pic;
                }
            };
            reader.readAsDataURL(file);
        });

        loginBtn.addEventListener('click', async () => {
            const user = usernameInput.value.trim();
            if (!user) {
                loginError.classList.remove('hidden');
                return;
            }
            currentUser.username = user;
            currentUser.bio = bioInput.value.trim() || "Sem bio";
            
            // UI Update
            headerUserInfo.innerHTML = `
                <img src="${currentUser.pic}" class="w-8 h-8 rounded-full border border-blue-500 object-cover">
                <div class="flex flex-col leading-tight">
                    <span class="font-bold text-sm text-gray-800">${currentUser.username}</span>
                </div>
            `;
            
            loginModal.classList.add('hidden');
            
            // Request Camera Permissions immediately
            statusText.innerText = "Permita o acesso à câmera...";
            await initCamera();
            statusText.innerText = "Pronto! Clique em INICIAR.";
        });

        // --- 2. Camera & WebGL ---
        async function initCamera() {
            if (localStream) return true;

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localStream = stream;
                sourceVideo.srcObject = stream;
                
                // Important: Wait for video to actually start
                await new Promise((resolve) => {
                    if (sourceVideo.readyState >= 1) resolve();
                    else sourceVideo.onloadedmetadata = () => resolve();
                });

                // Init WebGL
                localCanvas.width = 640;
                localCanvas.height = 480;
                initWebGL();
                renderLoop();

                // Create Canvas Stream (Processed Video)
                // 30fps
                canvasStream = localCanvas.captureStream(30);
                
                // Add Audio Track from original mic
                const audioTrack = stream.getAudioTracks()[0];
                if (audioTrack) {
                    canvasStream.addTrack(audioTrack);
                }

                return true;
            } catch (err) {
                console.error("Camera Error:", err);
                alert("Erro ao acessar câmera/microfone. Verifique as permissões do navegador.");
                statusText.innerText = "Erro: Sem Câmera";
                return false;
            }
        }

        // --- WebGL Setup (The fun part) ---
        function initWebGL() {
            gl = localCanvas.getContext('webgl');
            if (!gl) return;

            const vsSource = `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                void main() {
                    gl_Position = vec4(a_position, 0, 1);
                    v_texCoord = a_texCoord;
                }
            `;

            const fsSource = `
                precision mediump float;
                uniform sampler2D u_image;
                uniform vec2 u_mouse; // 0..1
                uniform float u_mode; // 0=none, 1=bulge, 2=pinch, 3=swirl
                varying vec2 v_texCoord;

                void main() {
                    vec2 uv = v_texCoord;
                    // Fix coordinate system if needed. 
                    // Usually texture coords 0,0 is top-left in webgl when loading video? 
                    // Actually in WebGL 0,0 is bottom-left usually, but DOM images are top-down. 
                    // We flip Y during upload or in shader. 
                    // Let's assume standard mapping.
                    
                    vec2 center = u_mouse;
                    // Because of the scaleX(-1) in CSS, we inverted X logic in JS event.
                    
                    float dist = distance(uv, center);
                    vec2 coord = uv;

                    if (u_mode == 1.0) { // BULGE
                        float radius = 0.25; 
                        float strength = 0.8; 
                        if (dist < radius) {
                            float percent = dist / radius;
                            if (percent < 1.0) {
                                // Simple bulge formula
                                float t = sin(percent * 1.5707); // pi/2
                                coord = center + (uv - center) * t;
                            }
                        }
                    } else if (u_mode == 2.0) { // PINCH
                        float radius = 0.3;
                        float strength = 0.5;
                        if (dist < radius) {
                            float percent = dist / radius;
                            coord = center + (uv - center) * (1.0 + strength * (1.0 - percent));
                        }
                    } else if (u_mode == 3.0) { // SWIRL
                        float radius = 0.35;
                        float angle = 4.0;
                        if (dist < radius) {
                            float percent = (radius - dist) / radius;
                            float theta = percent * percent * angle;
                            float s = sin(theta);
                            float c = cos(theta);
                            vec2 dir = uv - center;
                            coord = center + vec2(dot(dir, vec2(c, -s)), dot(dir, vec2(s, c)));
                        }
                    }

                    gl_FragColor = texture2D(u_image, coord);
                }
            `;

            const program = createProgram(gl, vsSource, fsSource);
            if (!program) return;
            shaderProgram = program;

            // Buffers
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,  1, -1, -1,  1,
                -1,  1,  1, -1,  1,  1,
            ]), gl.STATIC_DRAW);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            // Flip Y for texture coords to match standard image orientation
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 1,  1, 1,  0, 0,
                0, 0,  1, 1,  1, 0,
            ]), gl.STATIC_DRAW);

            // Attributes
            const positionLoc = gl.getAttribLocation(program, "a_position");
            const texCoordLoc = gl.getAttribLocation(program, "a_texCoord");

            gl.enableVertexAttribArray(positionLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(texCoordLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);

            // Texture
            texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }

        function createProgram(gl, vs, fs) {
            const createShader = (type, source) => {
                const s = gl.createShader(type);
                gl.shaderSource(s, source);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                    console.error("Shader Error", gl.getShaderInfoLog(s));
                    return null;
                }
                return s;
            };
            const v = createShader(gl.VERTEX_SHADER, vs);
            const f = createShader(gl.FRAGMENT_SHADER, fs);
            if (!v || !f) return null;

            const p = gl.createProgram();
            gl.attachShader(p, v);
            gl.attachShader(p, f);
            gl.linkProgram(p);
            return p;
        }

        function renderLoop() {
            if (!gl || !sourceVideo || sourceVideo.readyState < 2) {
                animationFrameId = requestAnimationFrame(renderLoop);
                return;
            }
            
            gl.useProgram(shaderProgram);

            // Update Texture from Video Element
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sourceVideo);

            // Uniforms
            const uMouse = gl.getUniformLocation(shaderProgram, "u_mouse");
            const uMode = gl.getUniformLocation(shaderProgram, "u_mode");

            let modeVal = 0.0;
            const mode = distortionSelect.value;
            if (mode === 'bulge') modeVal = 1.0;
            else if (mode === 'pinch') modeVal = 2.0;
            else if (mode === 'swirl') modeVal = 3.0;

            gl.uniform1f(uMode, modeVal);
            gl.uniform2f(uMouse, mouseX, mouseY);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            animationFrameId = requestAnimationFrame(renderLoop);
        }

        // Handle Mouse/Touch for Distortion Center
        // Note: Canvas is mirrored visually with CSS transform: scaleX(-1)
        // We need to invert X logic for the WebGL shader to match visual position
        function updateMouse(x, y, rect) {
            let normX = (x - rect.left) / rect.width;
            let normY = (y - rect.top) / rect.height;
            // Invert X because user sees mirrored canvas
            mouseX = 1.0 - normX; 
            // Invert Y because WebGL texture 0 is often bottom? 
            // Actually in our buffer setup 0,0 is bottom-left logic for texture mapping.
            // Let's test standard 1-Y first or just Y. 
            // Usually DOM events 0,0 is top-left.
            // If we want 0,0 to be top-left in shader, we just pass Y. 
            // But we flipped texture buffer.
            mouseY = 1.0 - normY;
        }

        localCanvas.addEventListener('mousemove', e => updateMouse(e.clientX, e.clientY, localCanvas.getBoundingClientRect()));
        localCanvas.addEventListener('touchmove', e => {
            e.preventDefault();
            updateMouse(e.touches[0].clientX, e.touches[0].clientY, localCanvas.getBoundingClientRect());
        });


        // --- 3. Matchmaking & WebRTC ---

        async function startSearch() {
            if (!localStream) {
                const ok = await initCamera();
                if (!ok) return;
            }

            // Reset UI
            startBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
            chatArea.innerHTML = '';
            appendSystemMessage("Procurando alguém online...");
            statusText.innerText = "Procurando...";

            // Look for waiting room
            try {
                const q = query(collection(db, "rooms"), where("status", "==", "waiting"), limit(1));
                const snapshot = await getDocs(q);

                if (!snapshot.empty) {
                    // Join existing
                    const roomDoc = snapshot.docs[0];
                    await joinRoom(roomDoc.id, roomDoc.data());
                } else {
                    // Create new
                    await createRoom();
                }
            } catch (e) {
                console.error(e);
                appendSystemMessage("Erro ao buscar sala. Tente novamente.");
                hangUp();
            }
        }

        async function createRoom() {
            role = 'caller';
            statusText.innerText = "Aguardando Alguém...";
            
            // Create Room Doc
            const roomRef = await addDoc(collection(db, 'rooms'), {
                status: 'waiting',
                created: serverTimestamp(),
                callerInfo: currentUser
            });
            roomId = roomRef.id;

            // Initialize PeerConnection
            createPeerConnection();

            // Listen for changes (Callee joining)
            unsubscribeRoom = onSnapshot(doc(db, 'rooms', roomId), async (snap) => {
                const data = snap.data();
                if (!data) return;

                // Partner Joined?
                if (data.calleeInfo && !strangerName.innerText.includes(data.calleeInfo.username) && strangerName.innerText === "Estranho") {
                    updateStrangerInfo(data.calleeInfo);
                    statusText.innerText = "Conectando...";
                }

                // Answer received?
                if (data.answer && !peerConnection.currentRemoteDescription) {
                    const rtcSessionDescription = new RTCSessionDescription(data.answer);
                    await peerConnection.setRemoteDescription(rtcSessionDescription);
                    statusText.innerText = "Conectado!";
                    enableChat(true);
                    appendSystemMessage("Você está conectado! Diga olá.");
                }
            });

            // Listen for ICE candidates from Callee
            listenForCandidates('calleeCandidates');
        }

        async function joinRoom(id, data) {
            roomId = id;
            role = 'callee';
            statusText.innerText = "Conectando...";
            
            // Mark room occupied
            await updateDoc(doc(db, 'rooms', roomId), {
                status: 'occupied',
                calleeInfo: currentUser
            });

            // Show Stranger Info
            if (data.callerInfo) updateStrangerInfo(data.callerInfo);

            createPeerConnection();

            // Listen for ICE candidates from Caller
            listenForCandidates('callerCandidates');

            // Handle Offer
            if (data.offer) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                await updateDoc(doc(db, 'rooms', roomId), {
                    answer: { type: answer.type, sdp: answer.sdp }
                });
                
                statusText.innerText = "Conectado!";
                enableChat(true);
                appendSystemMessage("Você está conectado! Diga olá.");
            }
        }

        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(servers);

            // Add Tracks
            if (canvasStream) {
                canvasStream.getTracks().forEach(track => peerConnection.addTrack(track, canvasStream));
            } else if (localStream) {
                // Fallback
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
            }

            peerConnection.ontrack = (event) => {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    console.log("Remote Stream Received");
                }
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate && roomId) {
                    const cName = role === 'caller' ? 'callerCandidates' : 'calleeCandidates';
                    addDoc(collection(db, 'rooms', roomId, cName), event.candidate.toJSON());
                }
            };

            // Data Channel
            if (role === 'caller') {
                dataChannel = peerConnection.createDataChannel("chat");
                setupDataChannel(dataChannel);
                
                // Create Offer
                createOffer();
            } else {
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannel(dataChannel);
                };
            }
        }

        async function createOffer() {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            // Update doc with offer
            // Note: We might have created the room before, now we update it
            await updateDoc(doc(db, 'rooms', roomId), {
                offer: { type: offer.type, sdp: offer.sdp }
            });
        }

        function setupDataChannel(channel) {
            channel.onopen = () => { console.log("Chat Channel Open"); };
            channel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'chat') appendMessage(data.text, 'stranger');
            };
        }

        function listenForCandidates(collectionName) {
            unsubscribeCandidates = onSnapshot(collection(db, 'rooms', roomId, collectionName), (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        try {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                        } catch (e) { console.error("Error adding candidate", e); }
                    }
                });
            });
        }

        // --- Helpers ---
        function updateStrangerInfo(info) {
            strangerProfile.classList.remove('hidden');
            strangerName.innerText = info.username || "Estranho";
            strangerBio.innerText = info.bio || "";
            if (info.pic) strangerPic.src = info.pic;
        }

        function hangUp() {
            // Reset UI
            startBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
            statusText.innerText = "Desconectado";
            strangerProfile.classList.add('hidden');
            strangerName.innerText = "Estranho";
            strangerPic.src = "";
            enableChat(false);
            appendSystemMessage("Você se desconectou.");

            // Cleanup WebRTC
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (unsubscribeRoom) unsubscribeRoom();
            if (unsubscribeCandidates) unsubscribeCandidates();
            if (dataChannel) dataChannel.close();

            // Clear Remote Video
            remoteVideo.srcObject = null;
            
            roomId = null;
            role = null;
        }

        function sendMessage() {
            const text = chatInput.value.trim();
            if (!text) return;
            chatInput.value = '';
            appendMessage(text, 'you');
            
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({ type: 'chat', text: text }));
            }
        }

        function appendMessage(text, type) {
            const div = document.createElement('div');
            div.className = 'chat-message';
            
            if (type === 'you') {
                div.innerHTML = `<span class="you-msg font-bold">Você:</span> ${text}`;
            } else {
                div.innerHTML = `<span class="stranger-msg font-bold">${strangerName.innerText}:</span> ${text}`;
            }
            chatArea.appendChild(div);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        function appendSystemMessage(text) {
            const div = document.createElement('div');
            div.className = 'system-msg';
            div.innerText = text;
            chatArea.appendChild(div);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        function enableChat(state) {
            chatInput.disabled = !state;
            sendBtn.disabled = !state;
            if (state) chatInput.focus();
        }

        // --- Listeners ---
        startBtn.addEventListener('click', startSearch);
        stopBtn.addEventListener('click', hangUp);
        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendMessage(); });
        
        window.addEventListener('beforeunload', hangUp);
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (!stopBtn.classList.contains('hidden')) {
                    hangUp();
                }
            }
        });

    </script>
</body>
</html>
