<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omegle Clone - PobreCraft</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f1f1f1;
            font-family: sans-serif;
        }
        .video-container {
            position: relative;
            background: #000;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 8px;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #localVideo {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 120px;
            height: 90px;
            border: 2px solid white;
            border-radius: 4px;
            z-index: 10;
            transform: scaleX(-1); /* Mirror effect */
        }
        /* Filters */
        .filter-grayscale { filter: grayscale(100%); }
        .filter-sepia { filter: sepia(100%); }
        .filter-invert { filter: invert(100%); }
        .filter-contrast { filter: contrast(160%); }
        .filter-hue { filter: hue-rotate(90deg); }
        .filter-blur { filter: blur(3px); }

        /* Chat styles */
        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 4px;
        }
        .stranger-msg { color: blue; }
        .you-msg { color: gray; }
        .system-msg { color: #555; font-style: italic; font-size: 0.9em; }
    </style>
</head>
<body class="h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-white p-4 shadow-md flex justify-between items-center">
        <h1 class="text-2xl font-bold text-gray-800"><span class="text-blue-500">Omegle</span> Clone</h1>
        <div class="text-sm text-gray-500" id="statusText">Desconectado</div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col md:flex-row p-4 gap-4 overflow-hidden">
        
        <!-- Video Section -->
        <div class="flex-1 flex flex-col gap-4">
            <div class="video-container flex-1 relative shadow-lg">
                <video id="remoteVideo" autoplay playsinline></video>
                <video id="localVideo" autoplay playsinline muted></video>
                
                <div class="absolute top-4 left-4 bg-black/50 text-white px-2 py-1 rounded text-sm z-20">
                    Estranho
                </div>
                <div class="absolute bottom-4 right-36 bg-black/50 text-white px-2 py-1 rounded text-sm z-20">
                    Você
                </div>
            </div>

            <!-- Controls -->
            <div class="bg-white p-4 rounded-lg shadow-md flex flex-wrap gap-4 items-center justify-between">
                <div class="flex gap-2 items-center">
                    <label class="font-semibold text-gray-700">Filtro Câmera:</label>
                    <select id="filterSelect" class="border rounded p-2 bg-gray-50">
                        <option value="">Normal</option>
                        <option value="filter-grayscale">Preto & Branco</option>
                        <option value="filter-sepia">Sépia</option>
                        <option value="filter-invert">Invertido</option>
                        <option value="filter-contrast">Alto Contraste</option>
                        <option value="filter-hue">Psicodélico</option>
                        <option value="filter-blur">Desfocado</option>
                    </select>
                </div>

                <div class="flex gap-2">
                    <button id="startBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded transition">
                        Iniciar
                    </button>
                    <button id="stopBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded transition hidden">
                        Parar / Pular
                    </button>
                </div>
            </div>
        </div>

        <!-- Chat Section -->
        <div class="w-full md:w-1/3 bg-white rounded-lg shadow-md flex flex-col h-1/2 md:h-full">
            <div id="chatArea" class="flex-1 p-4 overflow-y-auto border-b border-gray-200 bg-gray-50">
                <div class="system-msg">Bem-vindo ao Omegle Clone! Clique em "Iniciar" para encontrar alguém.</div>
            </div>
            <div class="p-4 flex gap-2">
                <input id="chatInput" type="text" placeholder="Digite uma mensagem..." class="flex-1 border rounded p-2 focus:outline-none focus:ring-2 focus:ring-blue-400" disabled>
                <button id="sendBtn" class="bg-gray-200 text-gray-600 px-4 py-2 rounded hover:bg-gray-300 transition" disabled>
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>

    </main>

    <!-- Firebase and Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, deleteDoc, getDoc, setDoc, query, where, getDocs, limit, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDsDeOjhkkKtXK8kBpuVORQ1FTI_EdBTdU",
            authDomain: "pobrecraft-c517c.firebaseapp.com",
            projectId: "pobrecraft-c517c",
            storageBucket: "pobrecraft-c517c.firebasestorage.app",
            messagingSenderId: "906438912132",
            appId: "1:906438912132:web:a3d9827600d3c0a52dbad1"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // WebRTC Config
        const servers = {
            iceServers: [
                { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }
            ]
        };

        // DOM Elements
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const filterSelect = document.getElementById('filterSelect');
        const statusText = document.getElementById('statusText');
        const chatArea = document.getElementById('chatArea');
        const chatInput = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');

        // State Variables
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let roomId = null;
        let role = null; // 'caller' or 'callee'
        let unsubscribeRoom = null; // Listener for room changes
        let unsubscribeCandidates = null; // Listener for ice candidates

        // --- Filter Logic ---
        filterSelect.addEventListener('change', (e) => {
            localVideo.className = e.target.value;
            // Note: Sending filtered video over WebRTC is complex (requires canvas processing).
            // For this clone, we apply the filter visually on the local element. 
            // To send it, we'd need to captureStream from a canvas. 
            // Let's keep it simple: visual only for now, or users can only see their own filter.
        });

        // --- Chat Logic ---
        function appendMessage(text, type) {
            const div = document.createElement('div');
            div.className = 'chat-message';
            if (type === 'you') {
                div.innerHTML = `<span class="you-msg font-bold">Você:</span> ${text}`;
            } else if (type === 'stranger') {
                div.innerHTML = `<span class="stranger-msg font-bold">Estranho:</span> ${text}`;
            } else {
                div.innerHTML = `<span class="system-msg">${text}</span>`;
            }
            chatArea.appendChild(div);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        async function sendMessage() {
            const text = chatInput.value.trim();
            if (!text || !roomId) return;
            
            chatInput.value = '';
            appendMessage(text, 'you');

            // Save message to subcollection 'messages' in the room document
            // Assuming we have read/write access. If not, we rely on data channel (WebRTC)
            // But let's try Data Channel for chat as it's cleaner for P2P text without DB latency.
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(text);
            } else {
                console.warn("Data channel not open");
            }
        }

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
        sendBtn.addEventListener('click', sendMessage);

        let dataChannel = null;

        // --- Media Setup ---
        async function openUserMedia() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localStream = stream;
                localVideo.srcObject = stream;
                return true;
            } catch (error) {
                console.error('Error accessing media devices.', error);
                alert('Erro ao acessar câmera/microfone. Verifique as permissões.');
                return false;
            }
        }

        // --- Signaling / Matching Logic ---

        async function createRoom() {
            const roomsRef = collection(db, 'rooms');
            // Create a new room with status 'waiting'
            const roomDoc = await addDoc(roomsRef, {
                status: 'waiting',
                created: serverTimestamp() // To help clean up old rooms if needed
            });
            roomId = roomDoc.id;
            role = 'caller';
            console.log(`Created room ${roomId} - waiting for someone to join...`);
            statusText.innerText = "Aguardando alguém...";
            appendMessage("Procurando alguém para conversar...", "system");

            // Initialize PC immediately to create offer
            createPeerConnection(); 

            // Listen for remote joining (when they create an Answer)
            unsubscribeRoom = onSnapshot(doc(db, 'rooms', roomId), async (snapshot) => {
                const data = snapshot.data();
                if (!data) return;

                if (data.answer && !peerConnection.currentRemoteDescription) {
                    console.log('Got remote answer!', data.answer);
                    const rtcSessionDescription = new RTCSessionDescription(data.answer);
                    await peerConnection.setRemoteDescription(rtcSessionDescription);
                    statusText.innerText = "Conectado com um estranho!";
                    appendMessage("Você está conversando com um estranho!", "system");
                    enableChat(true);
                }
            });

            // Listen for ICE candidates from Callee
            unsubscribeCandidates = onSnapshot(collection(db, 'rooms', roomId, 'calleeCandidates'), (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        let data = change.doc.data();
                        console.log(`Got new remote ICE candidate: ${JSON.stringify(data)}`);
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data));
                    }
                });
            });
        }

        async function joinRoom(roomDocId) {
            roomId = roomDocId;
            role = 'callee';
            console.log(`Joining room ${roomId}`);
            statusText.innerText = "Conectando...";
            appendMessage("Conectando...", "system");

            // Mark room as occupied so no one else joins
            // Note: In a real high-concurrency app, use transactions.
            await updateDoc(doc(db, 'rooms', roomId), { status: 'occupied' });

            createPeerConnection();

            // Listen for ICE candidates from Caller
            unsubscribeCandidates = onSnapshot(collection(db, 'rooms', roomId, 'callerCandidates'), (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        let data = change.doc.data();
                        console.log(`Got new remote ICE candidate: ${JSON.stringify(data)}`);
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data));
                    }
                });
            });

            // Create Offer trigger (Caller will have already created offer if logic was swapped, 
            // but here: Caller creates Room. 
            // WAIT -> WebRTC standard: Caller creates Offer. Callee creates Answer.
            
            // Re-evaluating flow:
            // 1. Caller creates room.
            // 2. Caller creates Offer and saves it to room doc.
            // 3. Callee finds room, reads Offer, sets RemoteDesc, creates Answer, saves Answer.
            // 4. Caller sees Answer, sets RemoteDesc.
            
            // Let's adjust createRoom to create offer immediately.
        }

        async function hangUp() {
            statusText.innerText = "Desconectado";
            appendMessage("Você se desconectou.", "system");
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            remoteStream = null;
            
            // Clean up listeners
            if (unsubscribeRoom) unsubscribeRoom();
            if (unsubscribeCandidates) unsubscribeCandidates();

            // Delete room if possible (clean up)
            if (roomId) {
                try {
                    // Try to mark as closed or delete
                    // await deleteDoc(doc(db, 'rooms', roomId));
                    // Often better to just leave it or mark closed
                } catch (e) { console.log(e); }
                roomId = null;
            }

            // Reset UI
            startBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
            enableChat(false);
            chatArea.innerHTML = '<div class="system-msg">Bem-vindo ao Omegle Clone! Clique em "Iniciar" para encontrar alguém.</div>';
        }

        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(servers);

            // Add local stream tracks
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Handle remote tracks
            peerConnection.ontrack = (event) => {
                event.streams[0].getTracks().forEach(track => {
                    remoteStream = new MediaStream([track]); // Create new stream or add to existing
                    remoteVideo.srcObject = event.streams[0];
                });
            };

            // ICE Candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    const collectionName = role === 'caller' ? 'callerCandidates' : 'calleeCandidates';
                    addDoc(collection(db, 'rooms', roomId, collectionName), event.candidate.toJSON());
                }
            };

            // Data Channel for Chat
            if (role === 'caller') {
                dataChannel = peerConnection.createDataChannel("chat");
                setupDataChannel(dataChannel);
                createOffer();
            } else {
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannel(dataChannel);
                };
                // Callee needs to read offer from DB first (handled in finding room logic)
            }
        }

        function setupDataChannel(channel) {
            channel.onopen = () => console.log("Chat channel open");
            channel.onmessage = (event) => {
                appendMessage(event.data, 'stranger');
            };
        }

        async function createOffer() {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            const roomWithOffer = {
                offer: {
                    type: offer.type,
                    sdp: offer.sdp
                },
                status: 'waiting',
                created: serverTimestamp()
            };
            
            // If room already created (via ID), update it. 
            // But here logic: Caller creates room doc WITH offer.
            // We need to fix the createRoom logic.
            await updateDoc(doc(db, 'rooms', roomId), { offer: roomWithOffer.offer });
        }

        async function createAnswer(roomData) {
            // Role is callee. Room ID is set.
            const offer = roomData.offer;
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            const roomAnswer = {
                answer: {
                    type: answer.type,
                    sdp: answer.sdp
                }
            };
            
            await updateDoc(doc(db, 'rooms', roomId), roomAnswer);
            statusText.innerText = "Conectado com um estranho!";
            appendMessage("Você está conversando com um estranho!", "system");
            enableChat(true);
        }

        // --- Main Control Flow ---
        
        async function startSearch() {
            // 1. Check permissions and get media
            const mediaOk = await openUserMedia();
            if (!mediaOk) return;

            startBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
            statusText.innerText = "Procurando...";

            // 2. Look for existing available room
            const q = query(collection(db, "rooms"), where("status", "==", "waiting"), limit(1));
            const querySnapshot = await getDocs(q);

            let foundRoom = null;
            querySnapshot.forEach((doc) => {
                foundRoom = { id: doc.id, ...doc.data() };
            });

            if (foundRoom) {
                // Join as Callee
                await joinRoom(foundRoom.id);
                // Need to pass the offer data to establish connection
                await createAnswer(foundRoom);
            } else {
                // Create as Caller
                await createRoom();
            }
        }

        function enableChat(enable) {
            chatInput.disabled = !enable;
            sendBtn.disabled = !enable;
            if(enable) chatInput.focus();
        }

        // Event Listeners
        startBtn.addEventListener('click', startSearch);
        stopBtn.addEventListener('click', () => {
            hangUp();
            // Optionally auto-restart:
            // startSearch();
        });

        // Handle page close
        window.addEventListener('beforeunload', () => {
            if (roomId) hangUp();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // If the Stop button is visible, click it
                if (!stopBtn.classList.contains('hidden')) {
                    stopBtn.click();
                }
            }
        });

    </script>
</body>
</html>
